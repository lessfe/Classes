#include <iostream>
#include <string>
using namespace std;

/*

ООП: Классы, объекты

*/

//class Human {
//public:
//    /*Здесь будут описываться св-ва класса*/
//
//    int age; /* --> Такое св-во также наз-ся полем класса */
//    string name; /* --> string тоже будет яв-ся классом в некотором роде, а name будет яв-ся его объектом*/
//
//     string secondName(string str1, string str2) { /*--> В данном случае мы создали функцию, которая склеивает две строки и возращает новую, 
//         данная фун-ия будет яв-ся методом класса someClass*/
//         string newStr = str1 + str2;
//         cout << endl << newStr << endl;
//         return newStr;
//     }
//    
//     void outData() {
//         cout << age << endl << name;
//         
//     }
//};

class Point
{
    
private:
    int size;
public:
    int *data;

    Point(int size) {      
        this->size = size;     
        this->data = new int[size];

        for (int i = 0; i < size; i++)
        {
            data[i] = i;
        }
        cout << "Вызвалася конструктор для объекта --> " << this << endl;
    }
    Point(const Point &other) { 
        this->size = other.size;
        this->data = new int[other.size];
        
        for (int i = 0; i < other.size; i++)
        {
            this->data[i] = other.data[i];

        }
    }
    Point& operator = (const Point& other) {  /*
        Т.К. (operator =) ДОЛЖЕН ВОЗВРАЩАТЬ ССЫЛКУ НА ТЕКУЩИЙ ОБЪЕКТ, ТО
        В КАЧ-ВЕ ТИПА ВОЗРАЩАЕМОГО ЗН-ИЯ НАМ НЕОБХОДИМО УКАЗАТЬ ТИП НАШЕГО КЛАССА, С ССЫЛКОЙ, Т.К. НАМ НЕ НУЖНО
        СОЗДАВАТЬ ОБЪЕКТ, ЧТОБЫ ПРОСТО ПРОСМОТРЕТЬ ЕГО, НАМ НУЖНА ССЫЛКА, ЧТОБЫ МЫ МОГЛИ ПРОСТО ТУДА ЗАГЛЯНУТЬ.

        ЕСЛИ БЫ В КАЧ-ВЕ ВОЗРАЩАЕМОГО ЗНАЧЕНИЯ БЫЛО VOID, ТО (operator =) ОТРАБОТАВ, НИЧЕГО БЫ НЕ ВОЗРАЩАЛ,
        И МЫ НЕ МОГЛИ БЫ ВЫПОЛНИТЬ ТАКОЕ ВЫРАЖЕНИЕ.
________________________________________________________________________________

        Point a(2);
        Point b(3);
        Point c(4);
        c = a = b; // --> a.operator= (b);

        Т.Е. ПОСЛЕ ВЫПОЛНЕНИЕ (a = b), ПЕРЕГРУЖЕННЫЕ ОПЕРАТОР ВЕРНЕТ НАМ ССЫЛКУ, И ЭТУ ССЫЛКУ
        МЫ БУДЕМ ПЕРЕДАВАТЬ ПРИ ВЫПОЛНЕНИИ ВТОРОГО ВЫРАЖЕНИЯ (c = a = b).

________________________________________________________________________________

        кл-во сл-во "operator" далее перегружаемый оператор "=" 
        в кач-ве пар-ов константная сслыка на объекта класса. Конст-я потомучто нам не нужно ничего менять, 
        в объекте, а ссылка потомучто нам нужно только посмотреть что лежит в объекте.*/
        cout << "Вызвалася оператор = --> " << this << endl;
        /*В операторе копирования мы были уверены, что когда вызывается конструктор для второго объекта,
        сам второй объект пустой, поэтому та реализации для перегруженнного оператора = нам не подходит.
        Т.к. произойдет утечка памяти*/
        this->size = other.size; // a.size = b.size; 2 = 3;
        this->data = new int[other.size]; // a.size = new int[3]
        delete[] this->data; // a.size = new int[3] 
        this->data = new int[other.size]; //   
        for (int i = 0; i < other.size; i++)
        {
            this->data[i] = other.data[i];
            
        }
        return *this;
    }
    ~Point() { 
        cout << "\nВызвалася деструктор для объекта --> " << this << endl;
        
        delete[] data;
        
    }
    
};

//void Foo(Point value) {
//   
//   cout << "Вызвалась функция Foo" << endl;
//   
//}

//Point Foo2() {
//    cout << "Вызвалась функция Foo2" << endl;
//    Point temp(2);
//    return temp;
//}

// class Point
//{
//public:
//    int x;
//    int y;
//    void Print() {
//        cout << "x:" << x << "\ny:" << y << "\nz:" << z;
//        printZ();
//    }
//private:
//    int z;
//    /*Здесь мы описываем метод printZ в private секции, и он будет недоступен, если обращаться к нему вне класса, но
//    мы можем обращаться к этому методу ВНУТРИ класса.
//
//    Таким образом можно сделать вывод, что внутри класса все св-ва яв-ся дружественными по-отношению друг к другу, вне
//    завсимости от модификатора доступа.
//    */
//    void printZ() {
//        cout << "\nz:" << z;
//    }
// };


int main()

{
    
    // Объект класаа, св-ва класса, методы класса
    /*Human humanFirst; --> value1 яв-ся объектом класса

    По сути это выглядит так:

    Human humanFirst {
        int age : 22,
        string name : "Vladislav"
    }

    У нас здесь есть объект с именем humanFirst класса Human, который хранит два св-ва: age, name;

    humanFirst.age = 22; --> Здесь мы обращаеся к методу объекта класса someClass
    cout<< humanFirst.secondName("Vladislav ", "Fedotov");
    humanFirst.name = "Adam";

    humanFirst.outData();
    output: 22
    Adam
    humanFirst.secondName("Vladislav", " Fedotov");
    output: Vladislav Fedotov*/

    // МОДИФИКАТОРЫ ДОСТУПА КЛАССА 
    /*
    class Point
{
public:
    int x;
    int y;
    void Print() {
        cout << "x:" << x << "\ny:" << y << "\nz:" << z;
        printZ();
    }
private:
    int z;

    /*Здесь мы описываем метод printZ в private секции, и он будет недоступен, если обращаться к нему вне класса, но
    мы можем обращаться к этому методу ВНУТРИ класса.

    Таким образом можно сделать вывод, что внутри класса все св-ва яв-ся дружественными по-отношению друг к другу, вне
    завсимости от модификатора доступа.

    void printZ() {
        cout << "\nz:" << z;
    }
};


    1. private - изначально все св-ва класса описываются в этом модификаторе доступа.
    2. public - чтобы получать доступ к св-ам классов извне, необходим этот модификатор доступа.
    3. protected - необходим, чтобы получать доступ к св-ам классов при наследовании, также недоступен, если обращаться к
    св-м классов обычным способом извне.

    Point firstPoint;
    firstPoint.x = 2;
    firstPoint.y = 3;
    firstPoint.Print();

    В данном случае, мы вызываем метод Print, который хранит две переменные из public блока,
    и одну из private блока, но не смотря на то, что одна переменная описана в private, при вызове
    метода Print, на экран выведутся все переменные.

    */

    // Метод get и set
    /*
    В ООП принято писать код так, чтобы данные были отделены от методов.
    Св-ва классов в ООП не принято передавать в public доступе

    Поэтому для того, чтобы получать доступ к эти данным у поля должен быть метод get и set

    class Point
{

private:
    int x;
    int y;
    int z;
public:

    int getX() {
        return x;
    }
    void setX(int valueX) {

        x = valueX;
    }
    void printPoints() {
        cout << "x = " << x << "\ny = " << y << "\nz = " << z;
    }

};

int main() {

    Point firstPoint;
    firstPoint.setX(5); // На данном этапе метод setX получит значение valueX и присвоит его переменной x

    int result = firstPoint.getX(); Здесь мы присваиваем переменной result вызов метода getX объекта firstPoint, который в теле метода
    просто вернет x и присвоит его в result
    cout << result; // output: 5

}

    */

    // Конструктор класса 
    /*
    -Конструктор - конструкция, которая предназначена для того, чтобы инициализировать сост-ие класса
    в какое-то начальное зн-ие, которое нужно пользователю.

            КОНСТРУКТОР С ПАРАМЕТРАМИ:

    -Если при создании класса, мы не описываем конструктор сами, то интерпретор сам скрыто от нас создает его,
    и если создать свой конструктор, и добавить в него входящие параметры:

    Point(int valueX, int valueY, int valueZ) {
        x = valueX;
        y = valueY;
        z = valueZ;

    }

    то при создании объекта класса, мы получим ошибку:
    "Для класса не сущ-ет конструктора по умолчанию."

    -Чтобы была возможность создавать объекты класса, необходимо при создании такого объекта, передавать в него
    те аргументы, чтомы указали в конструкторе с параметрами.

    Point firstPoint(5, 10, 15);

    -Реализация такого констркутора необходима тогда, когда допустим, мы не хотим,
    чтобы пользователь мог создать объект класса, запустить компилятор, и получить в консоле "мусор".
    -------------------------------------------------------

            КОНСТРУКТОР ПО УМОЛЧАНИЮ:

    -Конструктор по умолчанию не принимает никаких пар-ов.
    -------------------------------------------------------

    CLASS_NAME(){

    }

    -------------------------------------------------------
        class Point
    {

    private:
        int x;
        int y;
        int z;
    public:

        void printPoints() {
            cout << "x = " << x << "\ny = " << y << "\nz = " << z;
        }

        Point() { //--> КОН-ОР ПО УМО-ИЮ.
        x = 5;
        y = 10;
        z = 15;
        }
    };

    -------------------------------------------------------

    В нашем клаасе Point в private секции описаны св-ва (переменные), которые никак не инициализированы,
    у нас есть метод (фун-ия) printPoints, которая печатает эти переменные, но т.к. переменнные не инициализированы, то
    при вызове этого метода, на экран выведется "мусор". Поэтому для инициализации используем конструктор:

    Point() {
        x = 5;
        y = 10;
        z = 15;
    }

    -------------------------------------------------------


    */

    //ПЕРЕГРУЗКА КОНСТРУКТОРА КЛАСА
    /*
    С ПОМОЩЬЮ ПЕРЕГРУЗКИ КОНСТРУКТОРА КЛАССА МЫ МОЖЕМ ИНИЦИАЛИЗИРОВАТЬ КЛАСС РАЗНЫМИ СПОСОБАМИ

    ДОПУСТИМ У НАС КОНСТРУКТОР ПО УМОЛЧАНИЮ (БЕЗ ПАРАМЕТРОВ), НО МЫ ХОТИМ СОЗДАТЬ ОБЪЕКТ,
    КУДА СМОЖЕМ ПЕРЕДАТЬ ЗНАЧЕНИЯ В КАЧ-ВЕ АРГУМЕНТОВ, В ТАКОМ СЛУЧАЕ НУЖНО ПЕРЕГРУЗИТЬ
    КОНСТРУКТОР И СОЗДАТЬ НОВЫЙ С ТЕМ ЖЕ ИМЕНЕМ, НО ТОЛЬКО ДВУМЯ ВХОДЯЩИМИ ПАРАМЕТРАМИ:

    Point(int newX, int newY) {
        x = newX;
        y = newY;
    }

    Point secondPoint(1, 5);
    secondPoint.printPoints();

    */

    // ДЕСТРУКТОР КЛАССА

    /*
    -ПО СУТИ ПРОТИВОПОЛОЖЕН КОНСТРУКТУРУ, СРАБАТЫВАЕТ ПРИ РАЗРУШЕНИИ ОБЪЕКТА КЛАССА;
    -В ОТЛИЧИИ ОТ КОНСТРУКТОРА, ДЕСТРУКТОРА С ПАРАМЕТРАМИ БЫТЬ НЕ МОЖЕТ;
    -ДЕСТРУКТОР ВЫЗЫВАЕТСЯ ТОГДА, КОГДА МЫ ВЫХОДИМ ИЗ ЗОНЫ ВИДИМОСТИ ОБЪЕКТА,
    Т.Е. ИЗ ЗОНЫ ВИДИМОСТИ main;
    -КОГДА МЫ СОЗДАЕМ ДВА ОБЪЕКТА КЛАССА, ДЕСТРУКТОР СРАБОТАЕТ СНАЧАЛА ДЛЯ ВТОРОГО ОБЪЕКТА, ПОТОМ ДЛЯ ПЕРВОГО.

    class Point
{

private:
public:

    Point() {
        cout << "\nКонстрктор отработал\n";

    }
    ~Point() {
        cout << "\nДестркуктор отработал\n";
    }

};

    Point firstPoint;

    Point secondPoint;

    OUTPUT:

    ____________________________________

    Констрктор отработал

    Дестркуктор отработал

    Дестркуктор отработал

    ____________________________________


    В ЭТИХ СЛУЧАЯХ ДЕСТРУКТОР ВЫПОЛНИТСЯ ПОСЛЕ ТОГО КАК ОТРАБОТАЕТ МЕТОД printPoints У ВТОРОГО ОБЪЕКТА,
    ДАЛЕЕ ДЕСТРУКТОР СРАБОТАЕТ ДВА РАЗА ПОДРЯД.

    Пример:

        class Point
    {

    private:

        int object;

    public:

    Point(int *x) {
        object = *x;
        cout << "Объект: " << object << " Констрктор отработал\n";

        }

    ~Point() {
        cout << "\nОбъект: " << object << "\tДестркуктор отработал\n";
        }
    }

    Создадим функцию

    void Foo() {
    int x = 1;
    cout << "Начало выполнения\n\n";
    Point firstPoint(&x);
    cout << "\nКонец выполнения\n";

    }

    И будем вызывать ее из главно блок main;

    ___________________________________
    OUTPUT:
        Начало выполнения

    Объект: 1 Констрктор отработал

        Конец выполнения

    Объект: 1 Дестркуктор отработал
    ____________________________________

    Как мы можем заметить деструтокр отработает тогда, когда объект выйдет из зоны видимости в фу-ии,
    а произойдет это после строчки "    cout << "\nКонец выполнения\n";    "

    */

    // ДЕСТРУКТОР ДЛЯ ДИНАМИЧЕСКОГО МАССИВА
    /*
    class Point
{

private:

    int* object;
public:

    Point(int size) {
        cout << "Происходит создание массива\n";
        object = new int[size];
        for (int i = 0; i < size; i++)
        {
            object[i] = i;
            cout << object[i] << endl;
        }
    }

     ~Point() {
        delete[] object;
        cout << "Массив удален из ОП";
    }
};

int main() {
    Point firstPoint(5);
    }

    OUTPUT:
_________________________________
    Происходит создание массива
    0
    1
    2
    3
    4
    Массив удален из ОП
_________________________________

    В данном случае, при создании массива, нужно позаботиться об удалении его из памяти,
    поэтому после создания его в конструкторе: "    object = new int[size];    ",
    в деструкторе нужно очистить выделенную под этот массива память: "    delete[] object;    ".

    */

    // КЛЮЧЕВОЕ СЛОВО this
    /*
    Синтаксис этого ключевого слова следующий: this->
    "this->" равносильно этой записи "(*this)."

    this - хранит в себе адрес созданного объекта класса.

    Грубо говоря, firstpoint.str такая запись будет равносильна такой (*this).str,
    т.к. this хранит в себе адрес firstPoint объекта, то разыминовав такой this мы получим сам firstPoint

    firstpoint.str

    class Point
{

private:
public:

    Point() {
        cout << this << endl; //
________________________________________________________________
        OUTPUT:
        012FF9A7
        012FF99B
________________________________________________________________

};

    ТАКЖЕ ЕСЛИ ВЕРНУТЬСЯ К МЕТОДАМ GET И SET и внутри класса написать
    "   this->  " мы увидим доступные методы get и set для ключевого слова this.

    Пример использования this:

    class Point
{

private:
    int x;
    int y;
    int z;

public:
    int getX() {
        return x;
    }
    void setX(int y) { --> Если мы захотим вызвать метод setX, объекта firstPoint типа Point, и к примеру передать туда 5, чтобы значение int y,
    которое описано в private блоке, заменилось, на 5 следующим образом (" y = y; "), то в теле метода компилятор будет думать, что мы хотим присвоить эту 5 в переменную y,
    которая находится в теле метода, а не в переменную, которая описана выше.
    В таком случае нам нужно использовать синтаксис: "this->y = y;" который будет равносилен следующей записи "firstPoint.y = y"
    отличие только в том, что мы не можем получить доступ к св-ву int y; класса Point через объект fristPoint, т.к. это св-во описано в private блоке.

        y = y; --> НЕВЕРНО
        this->y = y; --> ВЕРНО


    }
    void printPoints() {
        cout << "x = " << x << "\ny = " << y << "\nz = " << z;
    }

int main() {
    Point firstPoint;
    firstPoint.setX(5);
    firstPoint.printPoints();
}

    */

    // КОНСТРУКТОР КОПИРОВАНИЯ
    /*
    СИНТАКСИС: CLASS_NAME(const CLASS_NAME &)

    ПРИМЕР 1, когда нам необходим конструктор копирования:

    class Point
{

private:
public:
    int data;

    Point(int data) {
        this->data = data;
        cout << "Вызвалася конструктор для объекта --> " << this << endl;
    }
    ~Point() {
        cout << "Вызвалася деструктор для объекта --> " << this << endl;
    }

};

void Foo(Point value) {

   cout << "Вызвалась функция Foo" << endl;

}

int main() {
    Point firstPoint(2);

    Foo(firstPoint);
}

    ШАГИ РАБОТЫ ПРОГРАММЫ БУДУТ СЛЕДУЮЩИЕ:
    1. Point firstPoint(2); --> ВЫЗЫВАЕМ КОНСТРУКТОР ДЛЯ ОБЪЕКТА.

    2. КОНСТРУКТОР ПЕЧАТАЕТ В КОНСОЛЬ СЛЕДУЮЩЕЕ:
    "Вызвалася конструктор для объекта --> 0039F9E8"

    3. ТАК КАК ДИСТРУКТОР ВЫЗОВЕТСЯ ТОЛЬКО ТОГДА, КОГДА МЫ ВЫЙДЕМ ИЗ ОБЛАСТИ ВИДИМОСТИ
    ФУ-ИИ MAIN, ТО СЛЕДУЩИЙ ШАГ:
    ВЫЗОВ ФУ-ИИ Foo(firstPoint) --> В КАЧ-ВЕ АРГУМЕНТА ПЕРЕДАЕМ ОБЪЕКТ КЛАССА Point

    4. ТАК ПРИ ОПРЕДЕЛЕНИИ ПАРМЕТРОВ ФУ-ИИ МЫ УКАЗАЛИ ЗНАЧЕНИЕ value НЕ ПО ССЫЛКЕ, ТО
    ДЛЯ КЛАССА Point СОЗДАСТСЯ НОВЫЙ ОБЪЕКТ НО ДЛЯ КОНСТРУКТОР ВЫЗОВЕТСЯ НЕ ЯВНО (СКРЫТНО ОТ НАС), Т.К.
    КОМПИЛЯТОР ДО СИХ ПОР РАБОТАЕТ С ОБЪЕКТОМ firstPoint (...Т.К. МЫ СОЗДАЛИ ОБЪЕКТ ЛОКАЛЬНО В КАЧ-ВЕ ПАРАМЕТРА ФУ-ИИ Foo).

    5. ВЫХОДИМ ИЗ ЗОНЫ ВИДИМОСТИ ФУ-ИИ И ДЛЯ ОБЪЕКТА value ПЕРЕХОДИМ В ДЕСТРУКТОР
    И ПЕЧАТАЕМ В КОНСОЛЬ:

    "Вызвалася деструктор для объекта --> 0039F910"

    6. ВЫХОДИМ ИЗ ЗОНЫ ВИДИМОСТИ ФУ-ИИ И ДЛЯ ОБЪЕКТА firstPoint ПЕРЕХОДИМ В ДЕСТРУКТОР
    И ПЕЧАТАЕМ В КОНСОЛЬ:

    "Вызвалася деструктор для объекта --> 0039F9E8"


___________________________________________________________
ПРИМЕР 2:
    ВСЕ ДЛЯ ТОГО ЖЕ КЛАССА

Point Foo2() {
    cout << "Вызвалась функция Foo2" << endl;
    Point temp(2);
    return temp;
}

int main() {

    Foo2();
}
___________________________________________________________

    ШАГИ РАБОТЫ ПРОГРАММЫ БУДУТ СЛЕДУЮЩИЕ:
    1. ВЫЗЫВЕТСЯ ФУ-ИЯ Foo2();

    2. ПЕЧАТАЕТСЯ:

    "Вызвалась функция Foo2"

    3. СОЗДАЕТСЯ НВОЫЙ ОБЪЕКТ В ТЕЛЕ ФУ-ИИ Foo2:

    Point temp(2);

    4. ВЫЗЫВАЕТСЯ КОНСТРУКТОР ДЛЯ ТАКОГО ОБЪЕКТА И ПЕЧАТАЕТСЯ:

    "Вызвалася конструктор для объекта --> 0113FA9C"

    5. ВЫХОДИМ ИЗ ЗОНЫ ВИДИМОСТИ ОБЪЕКТА temp.

    6. ВЫЗЫВАЕТСЯ ДЕСТРУКТОР И ПЕЧАТАЕТСЯ:
    "Вызвалася деструктор для объекта --> 0113FA9C"

    7. Т.К. МЫ СОЗДАВАЛИ ФУ-ИЮ Foo2 с типом возращаемого зн-ия Point,
    ТО ДЛЯ НЕЕ СОЗДАСТСЯ ОБЪЕКТ Foo2 НА ЭТАПЕ, КОГДА МЫ ДОЙДЕМ ДО СТРОЧКИ:

    "return temp"

    НО КОНСТРУКТОР НЕ БУДЕТ ВЫЗВАН ЯВНО, НО ЯВНО БУДЕТ ВЫЗВАН ДЕСТРУКТОР:
    И В КОНСОЛЬ НАПЕЧАТАЕТСЯ:

    "Вызвалася деструктор для объекта --> 0113FAC4"
___________________________________________________________

    ПРИМЕР 1 И 2 ПОКАЗЫВАЮТ ДЛЯ ЧЕГО НУЖНЫ КОНСТРУКТОРЫ КОПИРОВАНИЯ ДЛЯ КЛАССА.

ПРИМЕР 3: В ЭТОМ ПРИМЕРЕ В КОНСТРУКТОРЕ СОЗДАЕМ ДИНАМИЧЕСКИЙ МАССИВ, А В ДИСТРУКТОРЕ ЗАБОТИМЯ ОБ ОЧИСТКИ ПАМЯТИ ДЛЯ ТАКОГО МАССИВА,
    И ЗДЕСЬ БУДЕТ ПРОБЛЕМА:

    ПРИ СОЗДАНИИ ОБЪЕКТОВ КЛАССА, ДОПУСТИ ИХ 2, В КАЧ-ВЕ АРГУМЕНТА ДЛЯ ВТОРОГО ОБЪЕКТА МЫ МОЖЕМ ПЕРЕДАТЬ ТУДА ПЕРВЫЙ ОБЪЕКТ:

    Point firstPoint(2);
    Point secondPoint(firstPoint);

    ___________________ПОДРЕДАКТИРУЕМ НАШ КЛАСС___________________

    class Point
{

private:
public:
    int *data;

    Point(int size) {
        this->data = new int[size];

        for (int i = 0; i < size; i++)
        {
            data[i] = i;
        }
        cout << "Вызвалася конструктор для объекта --> " << this << endl;
    }
    ~Point() {

        cout << "Вызвалася деструктор для объекта --> " << this << endl;
        delete[] data;
    }

};

    ШАГИ РАБОТЫ ПРОГРАММЫ БУДУТ СЛЕДУЮЩИЕ:
    1. СОЗДАСТЯ ПЕРВЫЙ ОБЪЕКТ И ЗАПУСТИТСЯ КОНСТРУКТОР ДЛЯ НЕГО, В ТЕЛЕ КОНСТРУКТОРА ЗАПОЛНИТСЯ МАССИВ
    И В КОНСОЛЬ НАПЕЧАТАЕТСЯ:

    "Вызвалася конструктор для объекта --> 0058F808"
    Point firstPoint(2);

    2. ВЫЗЫВАЕТСЯ КОНСТРУКТОР КОПИРОВАНИЯ ПРИ СОЗДАНИИ ВТОРОГО ОБЪЕКТА, НО ОН НИКАК
    НЕ ОПРЕДЕЛЕН ВРУЧНУЮ, ПОЭТОМУ МЫ НЕ МОЖЕМ ЗАЙТИ В НЕГО, НО ТАКОЙ КОНСТРУКТОР СОЗДАЕТСЯ АВТОМАТИЧЕСКИ ПРИ СОЗДАНИИ ЛЮБОГО КЛАССА.

    3. ВЫХОДИМ ИЗ ЗОНЫ ВИДИМОСТИ ОБЪЕКТОВ И ВЫЗЫВАЮТСЯ ДИСТРУКТОРЫ:
    ВЫЗЫВАЕТСЯ ДИСТРУКТОР ДЛЯ ВТОРОГО ОБЪЕКТА И ПЕЧТАТАЕТСЯ:
    "Вызвалася деструктор для объекта --> 00CFF7F0"
    4. ОЧИЩАЕТСЯ ПАМЯТЬ ВЫДЕЛЕННАЯ ПОД НАШ ДИНАМИЧЕСКИЙ МАССИВ

    СЛЕДУЮЩИМ ШАГОМ ДОЛЖЕН ВЫЗВАТЬ ДИС-ОР ДЛЯ ПЕРВОГО ОБЪЕКТА, НО Т.К. ПРИ ВЫЗОВЕ ДИС-РА ДЛЯ ВТОРОГО ОБЪЕКТА,
    МЫ ОЧИСТИЛИ ПАМЯТЬ ОТ МАССИВА, ТО СРАБОТАЕТ ИСКЛЮЧЕНИЕ И ПРОГРАММА НЕ ЗАВЕРШИТСЯ БЕЗ ОШИБКИ.

-----------------------РЕАЛИЗАЦИЯ СОБСТВЕННОГО КОНСТРУКТОРА КОПИРОВАНИЯ-----------------------
    Логика реализации такого конструктора следующая:
        Если раньше мы имели два объекта, которые указывали на одну и туже ячейку памяти,
        то сейчас мы под второй объект создали новый массив и в него скопировали данные из первого.
        И мы получили два объекта с разными ячейками памяти, но которые хранят абсолютно одинковые данные массива.


    Point(const Point &other) { --> Парметр const потому что в том объ-е, котороый принимаем, ничего менять не будем
     other будет копироваться в this, поэтому синтаксиси будет по сути такой: " *this = &other "

     this->data = other.data; --> По такой сути компилятор раелизовывал собственный конструктор копирования, но нам так
     не подходит.

       // &other = firstPoint
       // int[0] = 0
       // int[1] = 1
       // other.size = 2

    this->size = other.size;
    this->data = new int[other.size];

    // this->data = new int[2];

    for (int i = 0; i < other.size; i++)
    {
    this->data[i] = other.data[i];

    // this->data[0] = other.data[0]; --> 0 = 0
    // this->data[1] = other.data[1]; -- > 1 = 1
    }
    cout << "Вызвалася конструктор копирвоания " << this << endl;
}
*/

     // ПЕРЕГРУЗКА ОПЕРАТОРА ПРИСВАИВАНИЯ 
    /*
________________________________________________________________________________
        Есть две переменные типа int
        int a = 3;
        int b = 4;
        a = b;

        После присваивания в переменную a переменную b, мы не изменим их адреса памяти у нас просто изменяться их
        значение.
________________________________________________________________________________
        Есть две переменные типа Point
        Point a(2);
        Point b(3);

        a = b;

        После присваивания в переменную a переменную b, мы ИЗМЕНИМ их адреса памяти и переменная a будет думать, что она 
        теперь переменная b.

        И когда будут вызываться деструкторы для объектов, то произойдет утечка памяти.
________________________________________________________________________________
        Если мы еще не создали объект, но хотим сразу присвоить ему зн-ие, то
        компилятор вызовет кон-ор копирования:

        Point a;
        Point b = a; --> Point b(a);
________________________________________________________________________________
        По сути оператор присваивания это фу-ия 

        Пример:
        int a = 3;
       
        void functionEqual(int a, 3) { 
        }   

        int a = 3; // --> int void functionEqual(int a, 3) {}

        РЕАЛИЗАЦИЯ:

Point& operator = (const Point& other) {  
        Т.К. (operator =) ДОЛЖЕН ВОЗВРАЩАТЬ ССЫЛКУ НА ТЕКУЩИЙ ОБЪЕКТ, ТО
        В КАЧ-ВЕ ТИПА ВОЗРАЩАЕМОГО ЗН-ИЯ НАМ НЕОБХОДИМО УКАЗАТЬ ТИП НАШЕГО КЛАССА, С ССЫЛКОЙ, Т.К. НАМ НЕ НУЖНО
        СОЗДАВАТЬ ОБЪЕКТ, ЧТОБЫ ПРОСТО ПРОСМОТРЕТЬ ЕГО, НАМ НУЖНА ССЫЛКА, ЧТОБЫ МЫ МОГЛИ ПРОСТО ТУДА ЗАГЛЯНУТЬ.

        ЕСЛИ БЫ В КАЧ-ВЕ ВОЗРАЩАЕМОГО ЗНАЧЕНИЯ БЫЛО VOID, ТО (operator =) ОТРАБОТАВ, НИЧЕГО БЫ НЕ ВОЗРАЩАЛ,
        И МЫ НЕ МОГЛИ БЫ ВЫПОЛНИТЬ ТАКОЕ ВЫРАЖЕНИЕ. 
________________________________________________________________________________

        Point a(2);
        Point b(3);
        Point c(4);
        c = a = b; // --> a.operator= (b);

        Т.Е. ПОСЛЕ ВЫПОЛНЕНИЕ (a = b), ПЕРЕГРУЖЕННЫЕ ОПЕРАТОР ВЕРНЕТ НАМ ССЫЛКУ, И ЭТУ ССЫЛКУ
        МЫ БУДЕМ ПЕРЕДАВАТЬ ПРИ ВЫПОЛНЕНИИ ВТОРОГО ВЫРАЖЕНИЯ (c = a = b).

________________________________________________________________________________

        кл-во сл-во "operator" далее перегружаемый оператор "="
        в кач-ве пар-ов константная сслыка на объекта класса. Конст-я потомучто нам не нужно ничего менять,
        в объекте, а ссылка потомучто нам нужно только посмотреть что лежит в объекте.

        cout << "Вызвалася оператор = --> " << this << endl;

        В операторе копирования мы были уверены, что когда вызывается конструктор для второго объекта,
        сам второй объект пустой, поэтому та реализации для перегруженнного оператора = нам не подходит.
        Т.к. произойдет утечка памяти

        this->size = other.size; // a.size = b.size; 2 = 3;
        this->data = new int[other.size]; // a.size = new int[3]
        delete[] this->data; // a.size = new int[3] 
        this->data = new int[other.size]; //   
        for (int i = 0; i < other.size; i++)
        {
            this->data[i] = other.data[i];

        }
        return *this;
            }

 ________________________________________________________________________________

            OUTPUT:

        Вызвалася конструктор для объекта --> 006FFE00
        Вызвалася конструктор для объекта --> 006FFDF0

        Вызвалася оператор = --> 006FFE00

        Вызвалася деструктор для объекта --> 006FFDF0
        Вызвалася деструктор для объекта --> 006FFE00
*/

    


    Point a(2);

    Point b(3);
    Point c(4);
    
    
    c = a = b; // --> a.operator= (b);

    
    
    
    

    

}
   

